
## 이미지로 컨테이너 만들기

- 이미지를 이용해서 컨테이너를 만든다.
- 이미지는 프로그램을 실행하는데 필요한 설정이나 종속성들을 가지고 있다.

- 이미지는 응용프로그램을 실행하는데 필요한 모든것을 포함하고 있다.

- 이미지
    - 시작시 실행될 명령어
        - run kakaotalk
    - 파일 스냅샷
        - 카카오톡 파일
        
    
- 이미지를 이용해서 컨테이너를 만든다.
- 컨테이너 자체가 프로그램이 실행되는것이 아니다.
- 컨테이너가 시작될때 실행할 명령어가 필요하다

- 파일 스냅샷은 디렉토리나 파일을 카피한것

- 이미지로 컨테이너 만드는 순서
    - Docker클라이언트에 docker run <Image> 입력해줍니다.
    - 도커 이미지에 있는 파일 스냅샷을 컨테이너 하드디스크에 옮겨줍니다.
    - 이미지에서 가지고 있는 명령어(컨테이너가 실행횔때 사용될 명령어를)이용해서
    카카오톡을 실행시켜 줍니다.
    
- Cgroup, 네임스페이스를 쓸수 있는이유
    - 컨테이너를 격리 시킬수 있는 이유는 Cgroup과 네임스페이스를 사용해서 이다.
    - 하지만 생각해보면 리눅스 환경에서만 사용된다.
- Cgroup과 네임스페이스는 Linux에서만 사용이 가능하다.
    - 나는 지금 윈도우나 맥OS를 사용하고 있다.
    - 어떻게 이것이 가능한가?
    - 터미널을 켠 후
    - docker version을 쳐보면 된다.
    - 도커 서버가 리눅스가 된다.
    

- 기본적인 도커 클라이언트 명령어 알아보기
    - docker 도커클라이언트 언급
    - run 컨테이너 생성및 실행
    - 이미지이름 이 컨테이너를 위한 이미지
    
- 작동 순서 복습
    - 도커 클라이언트에 명령어 입력후 도커 서버로 보냄
    - 도커 서버에서 컨테이너를 위한 이미지가 이미 캐쉬되어있는지 확인
    - 없으면 도커 허브에서 다운 받아옴 있다면 그 이미 가지고 있는 이미지로 컨테이너 생성
- 이미지로 컨테이너 생성하는 순서
    - 먼저 파일 스냅샷 되어있는것을 컨테이너의 하드 디스크 부분에 올린다
    - 시작 커맨드를 이용하여 어플리케이션을 실행

- docker run alpine ls
    - ls : 커맨드는 현재 디렉토리의 파일 리스트 표출
    - 4번째 자리는 원래 이미지가 가지고 있는 시작 명령어를 무시하고 여기에 있는 커맨드를 실행하게함
    
    
- alpine 이미지를 

- 이미지 이름 뒤에 다른 명령어를 더 붙여서 원래 이미지안에 있는 기본 커맨드는 무시가 되고 ls명령어가 실행됨
- alpine 이미지 파일 스냅샷 안에 이미 ls를 사용 가능하게 하는 파일이 있다.

- hello-world이미지는 ls를 못한다.


- 컨테이너들 나열하기
    - 현재 실행중인 컨테이너 나열
        - docker : 도커 클라이언트 언급
        - ps : process status
        
- 실습
    - 2개의 터미널을 작동
    - 첫번째 터미널에서 컨테이너 하나를 실행
    - 두번째 터미널에 docker ps로 확인
    
- ps
    - Container ID : 컨테이너의 고유한 아이디 해쉬값.
    - IMAGE : 컨테이너 생성시 사용한 도커 이미지
    - COMMAND : 컨테이너 시작시 실행될 명령어, 대부분 이미지 내장되어 있으므로 별도의 설정이 필요없다
    - CREATED : 컨테이너가 생성된 시간
    - STATUS : UP : 실행중 Exited 종료 Pause 일시정지 
    - PORTS: 컨테이너가 개방한 포트와 호스트에 연결한 포트, 특별한 설정하지 않는 경우 출력되지 않는다.
    - NAMES: 컨테이너 고유한 이름 , 컨테이너 생성시 --name옵션으로 이름을 설정하지 않으면
    도커 엔진이 임의로 형용사와 명사를 조합해 설정 id와 마찬가지로 중복이 안되고 docker rename명령어로 이름을
    변경할 수 있다. docker rename original-name change-name
    
- 원하는 항몽만 보기
    -  docker ps --format 'table{{.Names}}\t table{{.Image}}'
    
- 도커 컨테이너의 생명주기
    - 생성
        - docker create <이미지 이름>
        - docker run <이미지 이름>
    - 시작
        - docker start <시작할 컨테이너 아이디/이름>
    - 실행
        - docker stop <중지할 컨테이너 아이디/ 이름>
    - 중지
        - docker rm <삭제할 컨테이너 아이디/이름>
    - 삭제
    


- docker run = docker crate + docker start( -a attach)
    - a없이하면 그냥 id만 나온다.
    - docker 컨테이너가 실행될때 붙어있다가 아웃풋들을 화면에 표출해준다.
    
- docker stop vs docker kill
    - 도커의 생명주기중에서 중지부분 docker stop과 docker kill로 중지할수 있다.

- stop
    - Gracefully하게 중지를 시킨다
    - 자비롭고 그동안 하던 작업들을 (메시지를 보내고 있었따면 보내고 있던 메시지)완료하고 컨테이너를 중지시킨다.
- kill
    - stop과 달리 어떠한 것도 기다리지 않고 바로 컨테이너를 중지시킨다.
- docker stop -> sigterm - (grace period) -> sigkill -> main Process (Container)
- docker kill -> sigkill -> main Process (Container)

- 컨테이너 삭제하기
    - docker rm <아이디/이름>
    - 실행중인 컨테이너는 먼저 중지한 후에 삭제가능하다.
- 모든 컨테이너를 삭제하고 싶다면?
    - docker rm 'docker ps -a -q'
- 이미지를 삭제하고 싶다면?
    - docker rmi <이미지 id>
    
- 한번에 컨테이너 이미지 네트워크 모두 삭제하고 싶다면?
    - docker system prune
    
- 실행중인 컨테이너에 명령어 전달
    - 이미 실행중인 컨테이너에 명령어를 전달하고 싶다면?
    - docker exec <컨테이너 id>
    - 먼저 터미널 2개를 실행
    - 결과로만 보면 run이랑 비슷하긴 하다.
    - run은 새로 컨테이너를 만들어서 실행
    - exec은 이미 실행중인 컨테이너에 명령어 전달 
    
    
- 레디스를 이용한 도커환경
    - 레디스 서버가 먼저 작동하고 있어야함 -> 그후 레디스 클라이언트 실행후 명령어를 레디스 서버에 전달
    - 레디스 클라이언트 redis-cli - 레디스 서버 docker run redis
    - 명령어 set value1 hello
    
- 먼저 첫번째 터미널을 실행후 레디스 서버를 작동시키자
- 그후 레디스 클라이언트를 켜야하는데 첫번째 터미널에서는 아무것도 할 수 없다.
그러니 두번째 터미널을 켜서 레디스 클라이언트를 작동시킨다.
- 레디스 서버 작동중이나. 레디스 클라이언트 실행하려하지만 컨테이너 밖이라 안댐

- it?
    - -it 를 붙여줘야 명령어를 실행한후 계속 명령어를 적을수 있다.
    - -i interactive 상호적인 -t terminal
    - -it가 없다면 이렇게 그냥 ㄱedis를 실행하고 바로 나온다.

- 실행중인 컨테이너에서 터미널 생활 즐기기
    - 지금까지 실행중인 컨테이너에 명령어를 전달할때는
    - docker exec -it 컨테이너id 명령어
    - 이런식으로 명령어 하나 입력할때마다 이 모든것을 계속 입력해줬어야 한다.
    - 이러한 문제점을 해결해주기 위해 컨테이너안에 쉘이나 터미널 환경으로 접속을 해줄수가 있다.
    - sh , bash , zsh , powershell 이미지에 따라서 되는게 있고 안되는것이 있다.
    - 그안에서 여러가지 터미널에서 원하는 것이 가능하다.
       
- 도커이미지 만들어보기
    - 현재까지는 도커 이미지를 항상 도커 허브에 이미 있던것들만 가져와서 사용했다.
    우리가 직접 만든 도커이미지를 사용할수 있고
    
- 간단하게 도커 이미지 다시 복습하기
    - 도커 이미지는 컨테이너를 만들기 위해 필요한 설정이나 종속성들을 갖고있는 소프트웨어패키지이다.
    - 도커 이미지는 dockerhub에 이미 다른 사람들이 만들어 놓은것을 이용할수도 있다.
    직접 만든 도커 이미지를 사용할수 있고 직접만든건 dockerhub에 올릴수 있다.
    
- 컨테이너는 도커이미지로 생성
    - docker file작성 -> docker Imagefㅡㄹ 만들기 위한 설정 파일이다.
    컨테이너가 어떻게 행동해야하는지 설정을 정의한다.
    - 도커 클라이언트
        - 도커 파일에 입력된것들이 도커 클라이언트에 전달되어야 한다.
    -도커서버
        - 도커 클라이언트에 전달된 모든 중요한 작업들을 하는곳
        
- dockerfile을 만드는법
    - docker file이란?
        - 도커 이미지를 만들기 위한 설정 파일이다. 컨테이너가 어떻게 행동해야 하는지에 대한
        설정들을 정의해주는곳 이다.
 - 도커 파일 만드는 순서(도커 이미지가 필요한것이 무엇인지를 생각하기)
    - 베이스 이미지를 명시해준다(파일 스냅샷에 해당)
    - 추가적으로 필요한 파일을 다운받기 위한 몇가지 명령어를 명시해준다.( 파일 스냅샷에 해당)
    - 컨테이너 시작시 실행될 명령어를 명시해 준다.

- 베이스 이미지란?
    - 도커 이미지는 여러개의 레이어로 되어있다.
    - 그중에서 베이스 이미지는 이 이미지의 기반이 되는 부분이다.
    - 레어어는 중간단계의 이미지라고 생각하면 된다.
    - 만약 이 이미지에 무엇이 추가한다면?? 레이어가 추가 된다.
    - 레이어 캐싱
    
이미지 -> 레이어 -> 레이어 -> 베이스 이미지 (Base Image) OS라고 생각하면 된다.

    
- 실제로 만들면서 배우기!
    - 목표는 "hello 문구 출력하기"
    
- 도커 파일을 만들 폴더 하나 만들기 ex) dockerfile-folder
- qㅏㅇ금 생성한 도커파일 폴더를 에디터를 이용해서 실행
- 파일 하나 생

완성된 도커 파일로 어떻게 이미지르 ㄹ생성하냐
- 도커파일 -> 도커 클라이언트 -> 도커서버 -> 이미지
- 도커파일에 입력된것들이 도커클라이언트에 전달되어서 도커 서버가 인식하게 하여야한다.
docker build ./ 또는 docker build .
Build명령어는
- 해당 디렉토리내에서 dockerfiledㅣ라는 파일을 찾아서 도커 클라이언트에 전달시켜준다.
- docker build 뒤에 ./ . 는 현재 디렉토리를 가르킨다.

1. Alpine 이미지를 가져온다. 시작시 실행될 명령어 , 파일 스냅샷
1. 임시 컨테이너 생성 시작시 실행할 명령어가 아직 없음. 하드디스크에 파일 시스템 스냅샷 추가
1. 임시 컨테이너 시작시 실행할 명령어 추가 하드디스크에 파일 시스템 스냅샷이 이미 추가되었음
1. Alpine이미지 시작시 실행될 명령어 파일 스냅샷도 만들음

- 결론
    - 베이스 이미지에서 다른 종속성이나 새로운 커맨드를 추가할때는
    임시 컨테이너를 만든 후 그 컨테이너를 토대로 새로운 이미지를 만든다
    그리고 그 임시 컨테이너를 지운다.
    